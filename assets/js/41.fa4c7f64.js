(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{451:function(t,s,v){"use strict";v.r(s);var _=v(2),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"什么是跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是跨域"}},[t._v("#")]),t._v(" 什么是跨域")]),t._v(" "),s("p",[t._v("跨域是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。")]),t._v(" "),s("h2",{attrs:{id:"什么是同源策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是同源策略"}},[t._v("#")]),t._v(" 什么是同源策略")]),t._v(" "),s("p",[t._v("跨域是因为浏览器为了安全，限制了从脚本内发起的跨站HTTP请求。同源策略要求源相同才能正常进行通信，即协议，域名，端口相同，这三者不同则视为跨域。")]),t._v(" "),s("h2",{attrs:{id:"跨域的解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域的解决方案"}},[t._v("#")]),t._v(" 跨域的解决方案")]),t._v(" "),s("h3",{attrs:{id:"jsonp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[t._v("#")]),t._v(" JSONP")]),t._v(" "),s("p",[t._v("JSONP是JSON with Padding的简写。JSONP是一种非官方的跨域数据交互协议。")]),t._v(" "),s("p",[t._v("JSONP请求一定需要对方的服务器做支持才可以。")]),t._v(" "),s("p",[t._v("JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持GET方法具有局限性，不安全可能会遭受XSS攻击。")]),t._v(" "),s("p",[t._v("JSONP的使用")]),t._v(" "),s("p",[t._v("1.动态的创建一个script标签")]),t._v(" "),s("p",[t._v("2.设置script标签的src，设置回调函数")]),t._v(" "),s("p",[t._v("3.将script标签添加到head中发起请求")]),t._v(" "),s("p",[t._v("4.服务器接收到请求后，将数据放在一个指定名字的回调函数中，发送给浏览器")]),t._v(" "),s("p",[t._v("5.浏览器解析script标签，并执行回调函数")]),t._v(" "),s("p",[t._v("JSONP的缺点")]),t._v(" "),s("p",[t._v("1.只能发送GET请求")]),t._v(" "),s("p",[t._v("2.不安全可能会遭受XSS攻击")]),t._v(" "),s("h3",{attrs:{id:"跨域资源共享-cors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域资源共享-cors"}},[t._v("#")]),t._v(" 跨域资源共享 CORS")]),t._v(" "),s("p",[t._v("CORS需要浏览器和后端同时支持。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS，")]),t._v(" "),s("p",[t._v("CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。")]),t._v(" "),s("p",[t._v("因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。")]),t._v(" "),s("h3",{attrs:{id:"postmessage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#postmessage"}},[t._v("#")]),t._v(" postMessage")]),t._v(" "),s("p",[t._v("postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：")]),t._v(" "),s("ul",[s("li",[t._v("页面和其打开的新窗口的数据传递")]),t._v(" "),s("li",[t._v("多窗口之间消息传递")]),t._v(" "),s("li",[t._v("标签与嵌套的iframe消息传递")]),t._v(" "),s("li",[t._v("上面三个场景的跨域数据传递")])]),t._v(" "),s("p",[t._v("用法")]),t._v(" "),s("p",[t._v("postMessage(data,origin)方法接受两个参数")]),t._v(" "),s("ul",[s("li",[t._v("data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。")]),t._v(" "),s("li",[t._v('origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。')])]),t._v(" "),s("h3",{attrs:{id:"websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" WebSocket")]),t._v(" "),s("p",[t._v("WebSocket是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。")]),t._v(" "),s("p",[t._v("WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。")]),t._v(" "),s("p",[t._v("WebSocket需要在服务器和客户端都进行配置，才能正常工作。")]),t._v(" "),s("h3",{attrs:{id:"nodejs中间件代理-两次跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs中间件代理-两次跨域"}},[t._v("#")]),t._v(" Nodejs中间件代理(两次跨域)")]),t._v(" "),s("p",[t._v("Nodejs中间件代理是采用nodejs中间件的方式，通过后台接口转发，支持所有类型的跨域请求。")]),t._v(" "),s("h3",{attrs:{id:"nginx反向代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx反向代理"}},[t._v("#")]),t._v(" Nginx反向代理")]),t._v(" "),s("p",[t._v("Nginx反向代理是采用Nginx服务器，通过反向代理的方式实现跨域。")])])}),[],!1,null,null,null);s.default=a.exports}}]);